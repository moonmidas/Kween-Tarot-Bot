
<project_request>
# Tarot Card Telegram Bot
## Project Description
A Telegram bot designed exclusively for a specific community group, providing single-card tarot readings using the Rider-Waite deck, including both upright and reversed card interpretations. The bot uses Groq's API via the Vercel AI SDK for generating structured JSON responses, with a fallback to Claude (also via the Vercel AI SDK) if Groq is unavailable. Responses are delivered as an image with a formatted caption, including a pre-written general meaning (stored in a JSON file, generated by an LLM code generator) and a question-specific interpretation. Admins can enable or disable the bot to manage usage, and robust error handling ensures a smooth user experience. The bot is hosted on Vercel, uses webhooks for Telegram integration, and implements rate limiting for non-admin users, storing rate limit data in Convex.

## Target Audience
A community within a designated Telegram group. The bot will only respond to messages in this group, ensuring it serves the intended users exclusively.

## Desired Features
### Bot Functionality
- [ ] Handle the `/reading <question>` command.
    - [ ] Extract the user's question from the command input (e.g., `/reading Will I succeed?`).
    - [ ] Use Groq's API via the Vercel AI SDK with tool calling to generate a structured JSON response.
        - [ ] JSON includes:
            - `card`: Name of the tarot card (e.g., "The Sun").
            - `orientation`: "upright" or "reversed".
            - `interpretation`: A question-specific interpretation.
        - [ ] Example JSON:
            ```json
            {
              "card": "The Sun",
              "orientation": "upright",
              "interpretation": "In the context of your question, this suggests a positive outcome."
            }
            ```
    - [ ] If Groq is unavailable, fall back to Claude's API (via the Vercel AI SDK) for the same structured output.
    - [ ] Append a pre-written general meaning for the card (stored in a JSON file) to the response.

### Access Control
- [ ] Restrict bot functionality to a specific Telegram group.
    - [ ] Check the chat ID of incoming messages and ignore those from other groups or private chats.
- [ ] Implement an admin `/togglebot` command to enable or disable the bot.
    - [ ] Restrict this command to group admins (verified via Telegram's API).
    - [ ] Store the bot's enabled/disabled state in Convex.
    - [ ] When disabled, respond with: "The bot is currently disabled by an admin."

### Rate Limiting
- [ ] Implement rate limiting for non-admin users.
    - [ ] Limit non-admin users to 3 readings per day.
    - [ ] Track usage per user in Convex (e.g., storing user IDs, reading counts, and timestamps).
    - [ ] Respond with: "You have reached your daily limit of 3 readings. Please try again tomorrow." when the limit is exceeded.
    - [ ] Admins (verified via Telegram's API) are exempt from rate limits.

### Tarot Deck
- [ ] Use the Rider-Waite deck.
    - [ ] Include all 78 cards with both upright and reversed interpretations.
    - [ ] Total of 156 possible outcomes (78 upright + 78 reversed).

### Image Handling
- [ ] Enable uploading of tarot card images to the bot.
    - [ ] Images will be uploaded to the web by you, accessible via public URLs.
    - [ ] During setup, the bot will upload these images to Telegram and store the resulting file IDs.
    - [ ] Create a mapping (e.g., dictionary) of card names and orientations to image file IDs for quick lookup.
        - [ ] Separate images provided for upright and reversed cards, named with underscores (e.g., "The_Sun_Upright.jpg" and "The_Sun_Reversed.jpg").
        - [ ] Example mapping structure:
            ```json
            {
              "The Sun": {
                "upright": "telegram_file_id_123",
                "reversed": "telegram_file_id_456"
              },
              "The Moon": {
                "upright": "telegram_file_id_789",
                "reversed": "telegram_file_id_012"
              }
            }
            ```

### Response Delivery
- [ ] Deliver responses as a single message with image and caption.
    - [ ] Include the card name and orientation in bold (e.g., **The Sun (Upright)**).
    - [ ] Include the pre-written general meaning, italicized (e.g., *General Meaning: The Sun represents joy, success, and positivity.*).
    - [ ] Include the interpretation, italicized (e.g., *Interpretation: In the context of your question, this suggests a positive outcome.*).
    - [ ] Example response:
        ```
        [Image of The Sun]
        **The Sun (Upright)**
        *General Meaning: The Sun represents joy, success, and positivity.*
        *Interpretation: In the context of your question, this suggests a positive outcome.*
        ```

### Data Management
- [ ] Store pre-written general meanings for all 156 card-orientation combinations.
    - [ ] Store in a JSON file generated by an LLM code generator.
    - [ ] Example structure:
        ```json
        {
          "The Sun": {
            "upright": "The Sun represents joy, success, and positivity.",
            "reversed": "The Sun reversed indicates temporary setbacks or delayed success."
          },
          "The Moon": {
            "upright": "The Moon represents intuition, dreams, and the subconscious.",
            "reversed": "The Moon reversed suggests confusion or hidden fears."
          }
        }
        ```

### Error Handling
- [ ] Implement a retry mechanism for API calls.
    - [ ] Retry up to 3 times if the API call fails (e.g., due to network issues).
- [ ] Handle timeouts and rate limits.
    - [ ] Respond with: "The service is unavailable at the moment. Please try again later."
- [ ] Manage invalid card names.
    - [ ] If the generated card name or orientation doesn't match any in the image set, respond with: "An error occurred while generating your reading. Please try again."

## Design Requests
- [ ] Present readings as a single message with image and caption.
    - [ ] Use bold text for card name and orientation (e.g., **The Sun (Upright)**).
    - [ ] Use italicized text for general meaning and interpretation.

## Other Notes
- The bot will be developed in JavaScript/TypeScript (preferred for Vercel's serverless environment) using the Vercel AI SDK for Groq and Claude integration.
- Telegram integration will use webhooks instead of polling, suitable for Vercel hosting.
- The bot will be hosted on Vercel, leveraging its serverless architecture and Convex for storing state (e.g., bot enabled/disabled, user rate limits).
- Secure management of API keys (Groq, Claude, Telegram) is required, using Vercel's environment variables.
- Compliance with Telegram's terms of service is required.
- Future expansions could include support for multiple tarot decks or multi-card spreads (e.g., three-card past-present-future).
- Webhook setup instructions for Vercel are provided below to guide deployment.

### Webhook Setup Instructions
To set up webhooks on Vercel for Telegram integration, follow these steps:
1. **Create a Telegram Bot**:
   - Open Telegram and start a chat with `@BotFather`.
   - Send `/newbot` and follow the prompts to create a bot.
   - Name your bot (e.g., "TarotCardBot") and choose a username (e.g., "@TarotCardBot").
   - BotFather will provide a bot token (e.g., `123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11`). Save this token.

2. **Set Up Vercel Project**:
   - Create a new Vercel project via the Vercel dashboard or CLI (`vercel init`).
   - Choose a Node.js or Next.js template (Next.js is recommended for API routes).
   - Deploy the project to get a public URL (e.g., `https://your-bot.vercel.app`).

3. **Create a Webhook Endpoint**:
   - In your Vercel project, create an API route at `/api/telegram` (e.g., `pages/api/telegram.js` or `app/api/telegram/route.js` in Next.js).
   - Implement the endpoint to handle Telegram updates, process commands, and send responses.
   - Example implementation (in Next.js):
     ```javascript
     import { VercelRequest, VercelResponse } from '@vercel/node';

     export default async function handler(req: VercelRequest, res: VercelResponse) {
       if (req.method !== 'POST') {
         return res.status(405).send('Method Not Allowed');
       }

       const update = req.body;
       // Process the update (e.g., handle /reading, /togglebot commands)
       // Use Telegram Bot API to send responses
       return res.status(200).send('OK');
     }
     ```

4. **Set the Webhook**:
   - Use the Telegram Bot API to set the webhook URL to your Vercel endpoint.
   - Make a POST request to:
     ```
     https://api.telegram.org/bot<YOUR_BOT_TOKEN>/setWebhook?url=https://your-bot.vercel.app/api/telegram
     ```
   - You can do this via a tool like Postman, curl, or a script. Example with curl:
     ```bash
     curl -X POST "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/setWebhook?url=https://your-bot.vercel.app/api/telegram"
     ```
   - Telegram will now send all bot updates to this endpoint.

5. **Secure the Webhook**:
   - Telegram supports a secret token for webhook security. Set a secret token in your Vercel environment variables (e.g., `TELEGRAM_SECRET_TOKEN`).
   - Pass this token when setting the webhook:
     ```bash
     curl -X POST "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/setWebhook?url=https://your-bot.vercel.app/api/telegram&secret_token=<YOUR_SECRET_TOKEN>"
     ```
   - In your webhook endpoint, verify the token:
     ```javascript
     if (req.headers['x-telegram-bot-api-secret-token'] !== process.env.TELEGRAM_SECRET_TOKEN) {
       return res.status(401).send('Unauthorized');
     }
     ```

6. **Test the Webhook**:
   - Send a message to your bot in the designated group (e.g., `/reading test`).
   - Check Vercel logs (`vercel logs`) to ensure the webhook is receiving updates and processing them correctly.

7. **Store API Keys**:
   - Store your Telegram bot token, Groq API key, and Claude API key in Vercel's environment variables:
     - Go to your Vercel dashboard > Project Settings > Environment Variables.
     - Add:
       ```
       TELEGRAM_BOT_TOKEN=<YOUR_BOT_TOKEN>
       GROQ_API_KEY=<YOUR_GROQ_API_KEY>
       CLAUDE_API_KEY=<YOUR_CLAUDE_API_KEY>
       TELEGRAM_SECRET_TOKEN=<YOUR_SECRET_TOKEN>
       ```

</project_request>

<technical_specification>
Below is the comprehensive technical specification for the Tarot Card Telegram Bot, crafted based on the project request and starter template provided. The planning process is embedded within the thinking trace, which has been distilled into this structured, detailed document suitable for input into planning and code generation AI systems.

---

# Tarot Card Telegram Bot Technical Specification

## 1. System Overview
- **Core purpose and value proposition**: The Tarot Card Telegram Bot delivers single-card tarot readings using the Rider-Waite deck exclusively for a designated Telegram community group. It provides both upright and reversed interpretations, responding with an image and a formatted caption that includes a pre-written general meaning and a question-specific interpretation. Leveraging Groq's API (with Claude as a fallback) via the Vercel AI SDK, the bot ensures reliable operation. Hosted on Vercel with Telegram webhook integration and Convex for data storage, it includes admin controls, rate limiting, and robust error handling for a seamless user experience.
- **Key workflows**:
  1. **Reading Request**: Users send `/reading <question>`; the bot extracts the question, generates a reading via AI, retrieves the card image and general meaning, and sends a formatted response.
  2. **Admin Control**: Admins use `/togglebot` to enable/disable the bot, with state stored in Convex.
  3. **Rate Limiting**: Non-admin users are restricted to 3 readings daily, tracked in Convex.
  4. **Image Delivery**: Pre-uploaded card images are mapped to file IDs for efficient response delivery.
- **System architecture**: Built with Next.js on Vercel's serverless platform, the bot uses Telegram webhooks for real-time interaction, Convex for persistent data (bot state, user usage, image mappings), and the Vercel AI SDK for AI-driven tarot readings. API keys are secured via Vercel environment variables.

## 2. Project Structure
- **Detailed breakdown of project structure & organization**:
  - `/pages/api/webhook.js`: Main endpoint for Telegram webhook updates; processes commands and sends responses.
  - `/pages/api/setup.js`: Optional setup route to upload tarot images and store file IDs (run once during deployment).
  - `/utils/commands/reading.js`: Logic for `/reading <question>` command, including AI calls and response formatting.
  - `/utils/commands/togglebot.js`: Logic for `/togglebot` command, restricted to admins.
  - `/utils/telegram.js`: Functions for Telegram API interactions (e.g., `sendPhoto`, `getChatMember`).
  - `/utils/database.js`: Convex interaction functions (e.g., querying bot state, updating usage).
  - `/utils/ai.js`: Functions for calling Groq and Claude APIs via Vercel AI SDK with retry/fallback logic.
  - `/data/generalMeanings.json`: Static JSON file with general meanings for all 156 card-orientation combinations.
  - `/scripts/uploadImages.js`: Script to upload tarot card images to Telegram and save file IDs in Convex.
  - `/convex/_generated/`: Auto-generated Convex files (e.g., `convex.config.js` after setup).
  - `/convex/botState.js`, `/convex/userUsage.js`, `/convex/imageMappings.js`: Convex schema and query/mutation definitions.
  - `.env`: Environment variables for `TELEGRAM_BOT_TOKEN`, `GROQ_API_KEY`, `CLAUDE_API_KEY`, `TELEGRAM_SECRET_TOKEN`, `DESIGNATED_CHAT_ID`.

## 3. Feature Specification

### 3.1 Reading Request
- **User story and requirements**: Users in the designated group request a reading via `/reading <question>`. The bot responds with a card image and a caption containing the card name, orientation, general meaning, and interpretation.
- **Detailed implementation steps**:
  1. In `/pages/api/webhook.js`, verify `req.body.message.chat.id` matches `process.env.DESIGNATED_CHAT_ID`.
  2. Check if the message starts with `/reading`; extract the question (e.g., from `/reading Will I succeed?`, get "Will I succeed?").
  3. Query Convex (`botState.js`) for `enabled` status; if `false`, respond with "The bot is currently disabled by an admin."
  4. Use `getChatMember` (Telegram API) to check if the user is an admin; if not, query Convex (`userUsage.js`) for `count` where `user_id` and `date` (UTC) match today.
     - If `count >= 3`, respond with "You have reached your daily limit of 3 readings. Please try again tomorrow."
  5. Call Groq API via Vercel AI SDK (`ai.js`) with the question, requesting structured JSON:
     ```json
     {
       "card": "The Sun",
       "orientation": "upright",
       "interpretation": "In the context of your question, this suggests a positive outcome."
     }
     ```
     - Retry up to 3 times on failure; if all fail, fall back to Claude API with the same structure.
  6. Validate `card` and `orientation` against Rider-Waite deck (78 cards, upright/reversed).
  7. Retrieve general meaning from `/data/generalMeanings.json` using `card` and `orientation`.
  8. Fetch image file ID from Convex (`imageMappings.js`) using `card` and `orientation`.
  9. Format caption:
     ```js
     const caption = `**${card} (${orientation})**\n*General Meaning: ${generalMeaning}*\n*Interpretation: ${interpretation}*`;
     ```
  10. Send response via `sendPhoto` (Telegram API) with image file ID and caption (parse_mode: "Markdown").
  11. If non-admin, upsert Convex (`userUsage.js`) to increment `count` for `user_id` and today's `date`.
- **Error handling and edge cases**:
  - No question: Respond "Please provide a question for your reading."
  - Invalid chat ID: Ignore request silently.
  - API failure: "The service is unavailable at the moment. Please try again later."
  - Invalid card/orientation: "An error occurred while generating your reading. Please try again."
  - Missing image: Log error, send text-only response with caption.

### 3.2 Admin Control
- **User story and requirements**: Admins toggle bot availability with `/togglebot`, restricted to the designated group.
- **Detailed implementation steps**:
  1. Verify chat ID matches `process.env.DESIGNATED_CHAT_ID`.
  2. Check if message is `/togglebot`.
  3. Call `getChatMember` to confirm user status is "administrator" or "creator".
  4. Query Convex (`botState.js`) for current `enabled` value; update to opposite value (e.g., `true` to `false`).
  5. Respond with "Bot is now enabled" or "Bot is now disabled."
- **Error handling and edge cases**:
  - Non-admin user: "Only admins can use this command."
  - Concurrent toggles: Convex handles atomic updates; last write wins.

### 3.3 Rate Limiting
- **User story and requirements**: Non-admin users are limited to 3 readings/day, tracked in Convex.
- **Detailed implementation steps**:
  1. During `/reading`, if user is not an admin, query Convex (`userUsage.js`) for `user_id` and today's `date`.
  2. If no record, `count = 0`; if `count < 3`, proceed and upsert `count + 1`; if `count >= 3`, deny request.
- **Error handling and edge cases**:
  - Date mismatch: Use UTC consistently for `date` (e.g., "2023-10-01").

### 3.4 Image Handling
- **User story and requirements**: Bot uses pre-uploaded images for all 156 Rider-Waite outcomes.
- **Detailed implementation steps**:
  1. Run `/scripts/uploadImages.js` once:
     - Fetch images from public URLs (e.g., "The_Sun_Upright.jpg").
     - Use `sendPhoto` to upload to Telegram (e.g., bot's own chat), retrieve `file_id`.
     - Store in Convex (`imageMappings.js`) as a single document:
       ```json
       {
         "mappings": {
           "The Sun": { "upright": "file_id_123", "reversed": "file_id_456" }
         }
       }
       ```
  2. During reading, retrieve `file_id` using `card` and `orientation`.
- **Error handling and edge cases**:
  - Upload failure: Retry 3 times, log errors.
  - Missing mapping: Use default image or text-only response.

## 4. Database Schema
### 4.1 Tables
- **bot_state** (Convex collection):
  - `id` (string, auto-generated)
  - `enabled` (boolean, default: true)
- **user_usage** (Convex collection):
  - `id` (string, auto-generated)
  - `user_id` (string, Telegram user ID)
  - `date` (string, UTC, e.g., "2023-10-01")
  - `count` (integer, default: 0)
  - Index: `by_user_date` on `user_id`, `date`
- **image_mappings** (Convex collection):
  - `id` (string, auto-generated)
  - `mappings` (object, e.g., `{ "The Sun": { "upright": "file_id_123", "reversed": "file_id_456" } }`)

## 5. Server Actions

### 5.1 Database Actions
- **Get Bot State**:
  - Query: `convex.query("botState:get")`
  - Returns: `{ enabled: boolean }`
- **Toggle Bot State**:
  - Mutation: `convex.mutation("botState:toggle")`
  - Input: None
  - Updates `enabled` to opposite value
- **Get User Usage**:
  - Query: `convex.query("userUsage:get", { user_id, date })`
  - Returns: `{ count: number }` or `null`
- **Increment User Usage**:
  - Mutation: `convex.mutation("userUsage:increment", { user_id, date })`
  - Upserts document, increments `count`
- **Get Image File ID**:
  - Query: `convex.query("imageMappings:getFileId", { card, orientation })`
  - Returns: `string` (file_id)

### 5.2 Other Actions
- **AI API Call**:
  - Function: `callAI(question: string)` in `/utils/ai.js`
  - Tries Groq (`POST /v1/chat/completions`), falls back to Claude if unavailable
  - Returns:
    ```json
    { "card": string, "orientation": string, "interpretation": string }
    ```
- **Send Image with Caption**:
  - Function: `sendPhoto(chatId: string, fileId: string, caption: string)` in `/utils/telegram.js`
  - Endpoint: `POST https://api.telegram.org/bot<TOKEN>/sendPhoto`
  - Body: `{ chat_id, photo: fileId, caption, parse_mode: "Markdown" }`

## 6. Design System
### 6.1 Visual Style
- **Text Formatting**:
  - Bold: `**text**` (Markdown)
  - Italic: `*text*` (Markdown)
- **Caption Structure**:
  - `**Card (Orientation)**\n*General Meaning: text*\n*Interpretation: text*`

### 6.2 Core Components
- **Format Caption**:
  ```js
  function formatCaption(card, orientation, generalMeaning, interpretation) {
    return `**${card} (${orientation})**\n*General Meaning: ${generalMeaning}*\n*Interpretation: ${interpretation}*`;
  }
  ```

## 7. Component Architecture
### 7.1 Server Components
- **Webhook Handler** (`/pages/api/webhook.js`):
  - Processes `req.body`, routes to command handlers
  - Type: `NextApiHandler`
- **Command Handlers**:
  - `readingCommand(chatId: string, question: string)` in `/utils/commands/reading.js`
  - `toggleBotCommand(chatId: string, userId: string)` in `/utils/commands/togglebot.js`

### 7.2 Client Components
- N/A (Server-side only)

## 8. Authentication & Authorization
- **Admin Verification**:
  - Function: `isAdmin(chatId: string, userId: string)` in `/utils/telegram.js`
  - Calls `GET https://api.telegram.org/bot<TOKEN>/getChatMember`
  - Checks `status` is "administrator" or "creator"

## 9. Data Flow
- **Server/Client Data Passing**: Stateless webhook requests fetch data from Convex or JSON files.
- **State Management**: Convex stores persistent state; general meanings in static JSON.
</technical_specification>


# Implementation Plan

## [Setup and Configuration]
- [x] **Step 1: Set up Convex**
  - **Task**: Install the Convex CLI, initialize the project, and define schemas for `bot_state`, `user_usage`, and `image_mappings`. Implement queries and mutations to manage bot state, user usage tracking, and image file ID storage.
  - **Files**:
    - `/convex/schema.js`: Define schemas for `bot_state` (enabled: boolean), `user_usage` (user_id: string, date: string, count: number), and `image_mappings` (mappings: object).
    - `/convex/botState.js`: Add `getBotState` query (returns enabled) and `toggleBotState` mutation (flips enabled).
    - `/convex/userUsage.js`: Add `getUserUsage` query (returns count or null) and `incrementUserUsage` mutation (upserts count).
    - `/convex/imageMappings.js`: Add `getImageFileId` query (returns file_id) and `setImageFileId` mutation (sets file_id for card/orientation).
  - **Step Dependencies**: None
  - **User Instructions**: Install Convex CLI with `npm install -g convex`, then run `npx convex dev` in the project root and follow prompts to initialize Convex.

- [x] **Step 2: Clean up starter template**
  - **Task**: Remove unnecessary files from the starter template to streamline the project for the tarot bot.
  - **Files**:
    - `/utils/commands/cricket.js`: Delete this file.
    - `/utils/commands/ping.js`: Delete this file.
    - `/pages/api/hello.js`: Delete this file (not needed for webhook-based bot).
  - **Step Dependencies**: None
  - **User Instructions**: None

- [x] **Step 3: Implement database utility functions**
  - **Task**: Create functions in `/utils/database.js` to interact with Convex, using the queries and mutations from Step 1.
  - **Files**:
    - `/utils/database.js`: Implement `getBotState`, `toggleBotState`, `getUserUsage`, `incrementUserUsage`, `getImageFileId` using Convex client.
  - **Step Dependencies**: Step 1
  - **User Instructions**: None

- [x] **Step 4: Implement AI utility functions**
  - **Task**: Create a function in `/utils/ai.js` to call Groq's API (with Claude fallback) using the Vercel AI SDK. It should take a question and return structured JSON `{ card, orientation, interpretation }` with retry logic (3 attempts).
  - **Files**:
    - `/utils/ai.js`: Implement `callAI` with Vercel AI SDK, tool calling for structured output, and fallback to Claude.
  - **Step Dependencies**: None
  - **User Instructions**: Install Vercel AI SDK with `npm install ai` and ensure `GROQ_API_KEY` and `CLAUDE_API_KEY` are in `.env`.

- [x] **Step 5: Enhance Telegram utility functions**
  - **Task**: Update `/utils/telegram.js` to include `sendPhoto` for image responses and `isAdmin` for admin verification.
  - **Files**:
    - `/utils/telegram.js`: Add `sendPhoto(chatId, fileId, caption)` and `isAdmin(chatId, userId)` using Telegram API endpoints.
  - **Step Dependencies**: None
  - **User Instructions**: None

## [Command Handlers]
- [x] **Step 6: Implement the `/togglebot` command**
  - **Task**: Create logic in `/utils/commands/togglebot.js` to toggle the bot's state, restricted to admins, and send a confirmation message.
  - **Files**:
    - `/utils/commands/togglebot.js`: Implement `toggleBotCommand(chatId, userId)` using `isAdmin` and `toggleBotState`.
  - **Step Dependencies**: Steps 3, 5
  - **User Instructions**: None

- [x] **Step 7: Implement the `/reading` command**
  - **Task**: Create logic in `/utils/commands/reading.js` to handle `/reading <question>`, including bot state check, rate limiting, AI call, data retrieval, and response delivery.
  - **Files**:
    - `/utils/commands/reading.js`: Implement `readingCommand(chatId, userId, text)` with all required checks and `sendPhoto`.
  - **Step Dependencies**: Steps 3, 4, 5, 10
  - **User Instructions**: None

- [x] **Step 8: Update the `/help` command**
  - **Task**: Modify `/utils/commands/help.js` to list tarot bot commands (`/reading`, `/togglebot`) instead of the starter template's commands.
  - **Files**:
    - `/utils/commands/help.js`: Update `helpCommand(chatId)` with new command descriptions.
  - **Step Dependencies**: None
  - **User Instructions**: None

## [Webhook and Data]
- [x] **Step 9: Update the webhook handler**
  - **Task**: Modify `/pages/api/webhook.js` to verify the secret token, check the chat ID, and route `/togglebot`, `/reading`, and `/help` commands to their handlers, ignoring other messages.
  - **Files**:
    - `/pages/api/webhook.js`: Update handler with security checks and command routing.
  - **Step Dependencies**: Steps 6, 7, 8
  - **User Instructions**: None

- [x] **Step 10: Create general meanings JSON**
  - **Task**: Create `/data/generalMeanings.json` with pre-written meanings for all 156 card-orientation combinations (78 cards, upright and reversed).
  - **Files**:
    - `/data/generalMeanings.json`: Add JSON with structure like `{ "The Sun": { "upright": "...", "reversed": "..." } }`.
  - **Step Dependencies**: None
  - **User Instructions**: Populate `/data/generalMeanings.json` with the provided meanings (assumed to be supplied separately).

- [x] **Step 11: Upload images and store file IDs**
  - **Task**: Create a script in `/scripts/uploadImages.js` to fetch tarot card images from public URLs, upload them to Telegram, and store file IDs in Convex.
  - **Files**:
    - `/scripts/uploadImages.js`: Implement script to process 156 images and use `setImageFileId`.
  - **Step Dependencies**: Step 1
  - **User Instructions**: Upload all 156 tarot card images (e.g., "The_Sun_Upright.jpg") to a public URL, then run `node scripts/uploadImages.js` with the base URL as an argument.

- [x] **Step 12: Configure environment variables**
  - **Task**: Ensure all necessary environment variables are set in `.env` for the bot to function.
  - **Files**: None
  - **Step Dependencies**: None
  - **User Instructions**: Add to `.env`: `TELEGRAM_BOT_TOKEN`, `GROQ_API_KEY`, `CLAUDE_API_KEY`, `TELEGRAM_SECRET_TOKEN`, `DESIGNATED_CHAT_ID`.
